\documentclass{article}

\usepackage{amsmath,amssymb,amstext}

\usepackage{courier} %% Sets font for listing as Courier.
\usepackage{listings, xcolor}
\usepackage{url} % Add the url package to handle URLs
\usepackage{changepage} % Add the changepage package to adjust the width of the text

\lstset{
tabsize = 4, %% set tab space width
showstringspaces = false, %% prevent space marking in strings, string is defined as the text that is generally printed directly to the console
numbers = left, %% display line numbers on the left
commentstyle = \color{green}, %% set comment color
keywordstyle = \color{blue}, %% set keyword color
stringstyle = \color{red}, %% set string color
rulecolor = \color{black}, %% set frame color to avoid being affected by text color
basicstyle = \small \ttfamily , %% set listing font and size
breaklines = true, %% enable line breaking
numberstyle = \tiny,
}

\title{Java Programming}
\author{Sven Maibaum}
\date{\today{}}

\begin{document}
\maketitle
\tableofcontents

\newpage











\section{Introduction}
\subsection{Hello World}


\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello World!"); (*@\label{System.out.println}@*)
    }
}
\end{lstlisting}

\subsection{Hello World Program Explanation}

The "Hello World" program is a quintessential example in programming, often used as the initial step in learning a new language. In Java, this program demonstrates the fundamental structure and syntax. Below is a breakdown of its components:

\begin{enumerate}
  \item \textbf{Class Declaration:}
  \begin{lstlisting}[language=Java]
public class HelloWorld {
  \end{lstlisting}
  In Java, every application must contain at least one class. Each class has a name, and in this case, it is `HelloWorld`. The keyword `public` indicates that the class is accessible from other classes.

  \item \textbf{Main Method:}
  \begin{lstlisting}[language=Java]
public static void main(String[] args) {
  \end{lstlisting}
  The `main` method is the entry point for any Java application. It is where the program starts its execution. This method is always `public` (meaning it can be accessed from anywhere), `static` (it doesn't belong to a specific object), and `void` (it doesn't return any value). The `String[] args` parameter is used to store command-line arguments.

  \item \textbf{The Print Statement:}
  \begin{lstlisting}[language=Java]
System.out.println("Hello World!");
  \end{lstlisting}
  This line is the core of the program. The command `System.out.println` prints the string provided in its parentheses to the console. In this case, it outputs "Hello World!".

  \item \textbf{End of Main Method and Class:}
  The closing braces `\} ` mark the end of the `main` method and the `HelloWorld` class.
\end{enumerate}

\begin{text}
    In essence, when this program is executed, it prints the text "Hello World!" to the console. It is significant for its simplicity and for illustrating the basic syntax and structure of Java.
\end{text}


\section{Variables}
\subsection{Variable Declaration}

\begin{lstlisting}[language=Java]
int x = 5;
double y = 3.14;
long z = 1234567890;

boolean a = true; // or false

char c = 'b';
String s = "Hello World!";
\end{lstlisting}


\subsection{Variable Types Explanation}

Variables in Java are used to store data values. In Java, each variable must be declared with a specific type which determines the size and layout of the variable's memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.
The code snippet provided demonstrates different types of variable declarations:

\begin{enumerate}
  \item \textbf{Integer (int):}
  \begin{lstlisting}[language=Java]
int x = 5;
  \end{lstlisting}
  `int` is used to store integer values without a decimal point. In this example, `x` is an integer variable holding the value 5.

  \item \textbf{Double-Precision Floating Point (double):}
  \begin{lstlisting}[language=Java]
double y = 3.14;
  \end{lstlisting}
  `double` is a type that can store large floating-point numbers (numbers with decimal points). Here, `y` is a double with the value 3.14.

  \item \textbf{Long Integer (long):}
  \begin{lstlisting}[language=Java]
long z = 1234567890;
  \end{lstlisting}
  `long` is similar to `int` but has a wider range. It's used for integer values larger than what `int` can hold.

  \item \textbf{Boolean (boolean):}
  \begin{lstlisting}[language=Java]
boolean a = true; // or false
  \end{lstlisting}
  `boolean` represents one of two values: `true` or `false`. In this case, `a` is a boolean variable set to `true`.

  \newpage
  \item \textbf{Character (char):}
  \begin{lstlisting}[language=Java]
char c = 'b';
  \end{lstlisting}
  `char` is used for storing a single character. Here, `c` is a character variable holding the character 'b'.

  \item \textbf{String (String):}
  \begin{lstlisting}[language=Java]
String s = "Hello World!";
  \end{lstlisting}
  `String` is a sequence of characters used in Java for texts. `s` is a String variable containing "Hello World!".
\end{enumerate}

\begin{text}

Variables are fundamental in Java for storing and manipulating data. Understanding these types is crucial for developing in Java.

\end{text}


\section{Operators}
\subsection{Arithmetic Operators Explanation}

Arithmetic operators in Java are used to perform common mathematical operations. These operators include addition, subtraction, multiplication, division, and modulus. Here's a brief overview of each:

\begin{enumerate}
  \item \textbf{Addition (+):}
  Used to add two values.
  \begin{lstlisting}[language=Java]
int sum = 5 + 3; // sum will be 8
  \end{lstlisting}

  \item \textbf{Subtraction (-):}
  Used to subtract one value from another.
  \begin{lstlisting}[language=Java]
int difference = 5 - 3; // difference will be 2
  \end{lstlisting}

  \item \textbf{Multiplication (*):}
  Used to multiply two values.
  \begin{lstlisting}[language=Java]
int product = 5 * 3; // product will be 15
  \end{lstlisting}

  \item \textbf{Division (/):}
  Used to divide one value by another.
  \begin{lstlisting}[language=Java]
int quotient = 15 / 3; // quotient will be 5
  \end{lstlisting}

  \item \textbf{Modulus (\%):}
  Used to find the remainder of a division.
  \begin{lstlisting}[language=Java]
int remainder = 16 % 3; // remainder will be 1
  \end{lstlisting}
\end{enumerate}

\begin{text}

These arithmetic operators are fundamental in Java for performing mathematical calculations. They operate on primitive data types such as `int`, `double`, `long`, etc., and are crucial for a wide range of programming applications from simple calculations to complex algorithms.

\end{text}

\newpage
\subsection{Comparison Operators Explanation}

Comparison operators in Java are used to compare two values. These operators are critical in making decisions in your code, such as in `if` statements and loops. Here are the primary comparison operators:

\begin{enumerate}
  \item \textbf{Equal to (==):}
  Checks if two values are equal.
  \begin{lstlisting}[language=Java]
boolean isEqual = (5 == 3); // isEqual will be false
  \end{lstlisting}

  \item \textbf{Not Equal to (!=):}
  Checks if two values are not equal.
  \begin{lstlisting}[language=Java]
boolean isNotEqual = (5 != 3); // isNotEqual will be true
  \end{lstlisting}

  \item \textbf{Greater Than (>):}
  Checks if the value on the left is greater than the value on the right.
  \begin{lstlisting}[language=Java]
boolean isGreaterThan = (5 > 3); // isGreaterThan will be true
  \end{lstlisting}

  \item \textbf{Less Than (<):}
  Checks if the value on the left is less than the value on the right.
  \begin{lstlisting}[language=Java]
boolean isLessThan = (5 < 3); // isLessThan will be false
  \end{lstlisting}

  \item \textbf{Greater Than or Equal to (>=):}
  Checks if the value on the left is greater than or equal to the value on the right.
  \begin{lstlisting}[language=Java]
boolean isGreaterOrEqual = (5 >= 3); // isGreaterOrEqual will be true
  \end{lstlisting}

  \item \textbf{Less Than or Equal to (<=):}
  Checks if the value on the left is less than or equal to the value on the right.
  \begin{lstlisting}[language=Java]
boolean isLessOrEqual = (5 <= 3); // isLessOrEqual will be false
  \end{lstlisting}
\end{enumerate}

\begin{text}

Understanding and using these comparison operators is essential in Java, as they form the basis of controlling the flow of execution in programs, particularly in conditional statements and loops.

\end{text}


\newpage
\section{Logical Operators}
\subsection{Logical Operators Explanation}

Logical operators in Java are used to form compound boolean expressions, which are critical in controlling the flow of execution in programs, especially in conditional statements and loops. The primary logical operators are AND, OR, and NOT, represented by `\&\&`, `||`, and `!` respectively. Here's an overview:

\begin{enumerate}
  \item \textbf{AND (\&\&):}
  Returns `true` if both boolean expressions are true.
  \begin{lstlisting}[language=Java]
boolean result = (5 > 3) && (8 > 6); // result will be true
  \end{lstlisting}

\item \textbf{OR ($\parallel$):}
  Returns `true` if at least one of the boolean expressions is true.
  \begin{lstlisting}[language=Java]
boolean result = (5 < 3) || (8 > 6); // result will be true
  \end{lstlisting}

  \item \textbf{NOT (!):}
  Reverses the value of the boolean expression.
  \begin{lstlisting}[language=Java]
boolean result = !(5 < 3); // result will be true
  \end{lstlisting}
\end{enumerate}


\begin{text}

Understanding these logical operators is essential for creating complex conditions in your Java programs. They enable you to combine multiple conditions in `if` statements, `while` loops, and other control structures, allowing for more nuanced and precise control over your program's logic.

\end{text}


\section{Control Flow Statements}
\subsection{Introduction to Control Flow Statements}

Control flow statements in Java allow you to control the order in which statements are executed and decisions are made within your program. These include conditional statements like `if`-`else` and `switch`, as well as looping statements like `for`, `while`, and `do-while`. Control flow is essential for creating dynamic programs that can respond to different inputs and conditions.

\subsection{if-else Statements}
\subsubsection{Basic Structure}
The `if`-`else` statement is a fundamental control flow mechanism in Java. It allows the execution of different code blocks based on a boolean condition's truth value. The basic syntax is as follows:

\begin{lstlisting}[language=Java]
if (condition) {
    // Code to execute if condition is true
} else {
    // Code to execute if condition is false
}
\end{lstlisting}

Here, `condition` is any expression that returns a boolean value (either `true` or `false`). If the condition evaluates to `true`, the first block of code inside the `if` clause is executed. If the condition is `false`, the code inside the `else` block is executed.

\subsubsection{Nested if-else}
Nested `if`-`else` structures allow for checking multiple conditions sequentially. This is particularly useful when you need to perform different actions for more than two possible cases.

\begin{lstlisting}[language=Java]
if (condition1) {
    // Code if condition1 is true
} else if (condition2) {
    // Code if condition2 is true
} else {
    // Code if both conditions are false
}
\end{lstlisting}

In this structure, if `condition1` is `true`, its corresponding block of code is executed. If `condition1` is `false`, then `condition2` is evaluated. If `condition2` is `true`, its block of code is executed. If both `condition1` and `condition2` are false, the code in the `else` block is executed.

\textbf{Example:}

\begin{lstlisting}[language=Java]
int number = 15;
if (number > 20) {
    System.out.println("Number is greater than 20");
} else if (number > 10) {
    System.out.println("Number is greater than 10 but less than or equal to 20");
} else {
    System.out.println("Number is 10 or less");
}
\end{lstlisting}

In this example, the program will print "Number is greater than 10 but less than or equal to 20" because the `number` variable value (15) satisfies the second condition.


\newpage
\subsection{Switch Statements}
\subsubsection{Basic Structure}
The `switch` statement in Java is a multi-way branch statement. It allows a variable to be tested for equality against a list of values, where each value is called a "case". The variable being evaluated is known as the "switch expression".

\begin{lstlisting}[language=Java]
switch (expression) {
    case value1:
        // Code for case value1
        break;
    case value2:
        // Code for case value2
        break;
    // more cases
    default:
        // Default case code
}
\end{lstlisting}

Each case is followed by the value to compare and a colon. The `break` keyword is used to terminate a case; without it, the program continues to execute into the next case. The `default` case is optional and can be used to perform actions when none of the specified cases match the switch expression.

\subsubsection{Enhanced switch (Java 12 and later)}
Java 12 introduced an enhanced version of the `switch` statement, known as the `switch` expression. This new form simplifies the `switch` syntax and improves readability.

\begin{lstlisting}[language=Java]
switch (expression) {
    case value1 -> // Action for value1
    case value2 -> // Action for value2
    // more cases
    default -> // Default action
}
\end{lstlisting}

In the enhanced `switch`, the `->` operator replaces the traditional case label. This new syntax automatically includes the `break` statement, eliminating the need for explicit `break` statements after each case.

\newpage
\textbf{Example:}

\begin{lstlisting}[language=Java]
String day = "MONDAY";
String typeOfDay;
switch (day) {
    case "MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY" ->
        typeOfDay = "Weekday";
    case "SATURDAY", "SUNDAY" ->
        typeOfDay = "Weekend";
    default ->
        typeOfDay = "Invalid day";
}
System.out.println(typeOfDay);
\end{lstlisting}

This example uses an enhanced `switch` expression to determine the type of day. It will print "Weekday" as the `day` variable is set to "MONDAY".



\subsection{Loops}
Loops in Java are used to execute a block of code repeatedly under a given condition. They are essential for tasks that require repetitive actions.

\subsubsection{for Loop}
The `for` loop is used to iterate over a range of values. It consists of an initialization block, a condition, and an increment or decrement operation.

\begin{lstlisting}[language=Java]
for (initialization; condition; increment/decrement) {
    // Code to be executed
}
\end{lstlisting}

\textbf{Example:}

\begin{lstlisting}[language=Java]
for (int i = 0; i < 5; i++) {
    System.out.println("i = " + i);
}
\end{lstlisting}

This loop will print the value of `i` five times, from 0 to 4.

\subsubsection{Enhanced for Loop}
Also known as the "for-each" loop, it is used for iterating over collections and arrays. It simplifies loops by eliminating the need for a counter.

\begin{lstlisting}[language=Java]
for (type variable : array/collection) {
    // Code to be executed
}
\end{lstlisting}

\newpage
\textbf{Example:}

\begin{lstlisting}[language=Java]
String[] colors = {"Red", "Green", "Blue"};
for (String color : colors) {
    System.out.println(color);
}
\end{lstlisting}

This loop will print each element in the `colors` array.

\subsubsection{while Loop}
The `while` loop repeatedly executes a block of statements as long as a specified condition is `true`.

\begin{lstlisting}[language=Java]
while (condition) {
    // Code to be executed
}
\end{lstlisting}


\textbf{Example:}

\begin{lstlisting}[language=Java]
int i = 0;
while (i < 5) {
    System.out.println("i = " + i);
    i++;
}
\end{lstlisting}

This loop will print the value of `i` until it reaches 4.

\subsubsection{do-while Loop}
The `do-while` loop is similar to the `while` loop but guarantees that the block of code is executed at least once.

\begin{lstlisting}[language=Java]
do {
    // Code to be executed
} while (condition);
\end{lstlisting}

\textbf{Example:}

\begin{lstlisting}[language=Java]
int i = 0;
do {
    System.out.println("i = " + i);
    i++;
} while (i < 5);
\end{lstlisting}

This loop will execute the print statement at least once, even if the condition `i < 5` is false initially.


\newpage\subsection{Jump Statements}
Jump statements in Java, such as `break` and `continue`, alter the normal flow of execution based on certain conditions.

\subsubsection{break}
The `break` statement is used to exit from a loop or switch statement before it has completed its normal cycle.

\textbf{Example in a loop:}

\begin{lstlisting}[language=Java]
for (int i = 0; i < 10; i++) {
    if (i == 6) {
        break;
    }
    System.out.println("i = " + i);
}
\end{lstlisting}

In this example, the loop will terminate when `i` equals 6.

\subsubsection{continue}
The `continue` statement skips the current iteration of a loop and proceeds to the next iteration.

\textbf{Example:}

\begin{lstlisting}[language=Java]
for (int i = 0; i < 10; i++) {
    if (i == 6) {
        continue;
    }
    System.out.println("i = " + i);
}
\end{lstlisting}

In this loop, the number 6 will be skipped, and the loop will continue with 7.


\newpage
\section{Examples of Combining Control Flow Statements}
Combining different control flow statements is a common practice in Java programming. It allows for more complex logic and decision-making processes. This section provides examples demonstrating how to effectively combine `if-else`, `switch`, and loop statements.

\subsection{Combining if-else with Loops}
\textbf{Example:} Using `if-else` inside a `for` loop to perform different actions based on the loop variable.

\begin{lstlisting}[language=Java]
for (int i = 1; i <= 10; i++) {
    if (i % 2 == 0) {
        System.out.println(i + " is even");
    } else {
        System.out.println(i + " is odd");
    }
}
\end{lstlisting}

This example prints whether each number from 1 to 10 is odd or even.

\subsection{Nested Loops}
\textbf{Example:} Using nested loops to create a multiplication table.

\begin{lstlisting}[language=Java]
for (int i = 1; i <= 5; i++) {
    for (int j = 1; j <= 5; j++) {
        System.out.println(i + " * " + j + " = " + (i * j));
    }
}
\end{lstlisting}

This nested loop generates a 5x5 multiplication table.

\newpage
\subsection{Switch Case inside a Loop}
\textbf{Example:} Using a `switch` case inside a `while` loop to create a menu-driven program.

\begin{lstlisting}[language=Java]
int choice;
Scanner scanner = new Scanner(System.in);
while (true) {
    System.out.println("1. Print Hello");
    System.out.println("2. Print Java");
    System.out.println("3. Exit");
    System.out.print("Enter your choice: ");
    choice = scanner.nextInt();
    
    switch (choice) {
        case 1:
            System.out.println("Hello");
            break;
        case 2:
            System.out.println("Java");
            break;
        case 3:
            System.out.println("Exiting...");
            System.exit(0);
        default:
            System.out.println("Invalid choice");
    }
}
\end{lstlisting}

This program continuously presents a menu to the user. Depending on the user's choice, it performs different actions.

\subsection{Using break and continue in Loops}
\textbf{Example:} Demonstrating the use of `break` and `continue` in a loop.

\begin{lstlisting}[language=Java]
for (int i = 1; i <= 10; i++) {
    if (i == 5) {
        continue; // Skip the current iteration when i is 5
    }
    if (i == 8) {
        break; // Exit the loop when i is 8
    }
    System.out.println("i = " + i);
}
\end{lstlisting}

In this loop, the number 5 is skipped, and the loop terminates when it reaches 8.


\newpage
\section{Arrays}
\subsection{Introduction to Arrays}
Arrays in Java are a fundamental data structure used to store multiple values of the same type in a single variable. An array can hold primitives (like `int`, `double`) or objects (like `String`, custom objects). Arrays are fixed in size; the length is set when the array is created and cannot be changed later.

\subsubsection{Creating Arrays}
To create an array in Java, you specify the type of elements it will hold, followed by square brackets, and then the array name. Arrays can be declared in several ways.

\textbf{Example 1:} Declaring an array with specified size.

\begin{lstlisting}[language=Java]
int[] numbers = new int[5];
\end{lstlisting}

This code snippet creates an array named `numbers` that can hold five `int` values. Initially, all elements are set to the default value for integers, which is 0.

\textbf{Example 2:} Initializing an array with values.

\begin{lstlisting}[language=Java]
String[] colors = {"Red", "Green", "Blue"};
\end{lstlisting}

Here, an array of `String` type named `colors` is created and initialized with three values: "Red", "Green", and "Blue".

\subsubsection{Accessing Array Elements}
Array elements are accessed by their index. Array indices start at 0, so the first element is at index 0, the second element at index 1, and so on.

\textbf{Example:} Accessing elements in the `colors` array.

\begin{lstlisting}[language=Java]
String firstColor = colors[0]; // Accesses the first element
colors[1] = "Yellow"; // Modifies the second element
\end{lstlisting}

In this example, `firstColor` will be "Red", and the second element in the `colors` array is changed to "Yellow".



\newpage
\subsection{Iterating Over Arrays}
To process each element in an array, you can use a loop. The `for` loop and the enhanced `for-each` loop are commonly used for this purpose.

\subsubsection{Using the for Loop}
\textbf{Example:} Iterating over the `numbers` array with a `for` loop.

\begin{lstlisting}[language=Java]
for (int i = 0; i < numbers.length; i++) {
    System.out.println("Element at index " + i + ": " + numbers[i]);
}
\end{lstlisting}

This loop iterates over each element in the `numbers` array, accessing elements using their indices.

\subsubsection{Using the for-each Loop}
\textbf{Example:} Iterating over the `colors` array with a `for-each` loop.

\begin{lstlisting}[language=Java]
for (String color : colors) {
    System.out.println(color);
}
\end{lstlisting}

The `for-each` loop simplifies the syntax for iterating over arrays. It eliminates the need for an index variable and directly provides access to each element.



\newpage
\subsection{Multidimensional Arrays}
Multidimensional arrays are arrays of arrays. Each element of a multidimensional array is itself an array. The most common type is the two-dimensional array, often used to represent matrices or grid-like structures.

\subsubsection{Creating and Accessing Two-Dimensional Arrays}
\textbf{Example:} Creating and accessing a two-dimensional array.

\begin{lstlisting}[language=Java]
int[][] matrix = new int[3][3]; // A 3x3 matrix

// Assigning values
matrix[0][0] = 1;
matrix[0][1] = 2;
matrix[0][2] = 3;
// ...continue for other elements

// Accessing values
int firstElement = matrix[0][0]; // Accesses 1
\end{lstlisting}

This example demonstrates creating a 3x3 matrix and accessing its elements. Each element in the matrix can be accessed using two indices - the first for the row and the second for the column.

\subsubsection{Iterating Over Two-Dimensional Arrays}
\textbf{Example:} Iterating over all elements in a two-dimensional array.

\begin{lstlisting}[language=Java]
for (int i = 0; i < matrix.length; i++) {
    for (int j = 0; j < matrix[i].length; j++) {
        System.out.println("Element at [" + i + "][" + j + "]: " + matrix[i][j]);
    }
}
\end{lstlisting}

This nested loop iterates over each row and column of the matrix, printing out each element's value.



\newpage
\subsection{Common Operations on Arrays}
Arrays in Java can be used with various operations like sorting, searching, and modifying elements. Here are some common operations:

\subsubsection{Sorting an Array}
Java provides utility methods to sort arrays. The `Arrays.sort()` method can be used to sort an array in ascending order.

\textbf{Example:} Sorting an array of integers.

\begin{lstlisting}[language=Java]
int[] numbers = {4, 2, 9, 1, 5};
Arrays.sort(numbers);

for (int number : numbers) {
    System.out.println(number);
}
\end{lstlisting}

This code sorts the `numbers` array in ascending order and prints the sorted elements.

\subsubsection{Searching for an Element}
To search for an element in an array, the `Arrays.binarySearch()` method can be used. The array must be sorted before performing a binary search.

\textbf{Example:} Searching for an element in a sorted array.

\begin{lstlisting}[language=Java]
int index = Arrays.binarySearch(numbers, 9); // Searching for 9
System.out.println("Index of 9: " + index);
\end{lstlisting}

This code searches for the number 9 in the `numbers` array and prints its index.



\newpage
\section{Methods}
\subsection{Introduction to Methods}
Methods in Java are a way of encapsulating a set of statements to perform a specific task. They allow for code reuse, better organization, and more readable and maintainable code. A method in Java can be understood as a collection of statements grouped together to perform an operation.

When you call a method, you are telling Java to execute the method's statements. After the method has finished executing, the program control is returned to the point where the method was called. This modular approach enables you to break down complex problems into smaller, more manageable tasks.

\subsubsection{Defining a Method}
To define a method in Java, you need to specify its visibility (like `public` or `private`), return type, method name, and parameters (if any). The syntax is as follows:

\begin{lstlisting}[language=Java]
returnType methodName(parameterList) {
    // Method body
}
\end{lstlisting}

\textbf{Example:} Defining a simple method to add two numbers.

\begin{lstlisting}[language=Java]
public int addNumbers(int num1, int num2) {
    int sum = num1 + num2;
    return sum;
}
\end{lstlisting}

This method, `addNumbers`, takes two integer parameters and returns their sum.

\subsubsection{Invoking a Method}
You call or invoke a method by using its name followed by arguments (if the method accepts parameters).

\textbf{Example:} Calling the `addNumbers` method.

\begin{lstlisting}[language=Java]
int result = addNumbers(5, 10); // result will be 15
\end{lstlisting}

In this example, `addNumbers` is called with two arguments, 5 and 10. The method returns 15, which is assigned to the variable `result`.



\newpage
\subsection{Parameter Passing and Return Types}
Methods in Java can accept parameters and return results. Parameters allow methods to operate on different data and return types specify the type of value the method will return.

\subsubsection{Parameters}
Parameters are specified in the method declaration. When a method is called, you pass a value to the parameter. This value is referred to as an argument.

\textbf{Example:} A method with multiple parameters.

\begin{lstlisting}[language=Java]
public void printDetails(String name, int age) {
    System.out.println("Name: " + name + ", Age: " + age);
}
\end{lstlisting}

This method, `printDetails`, takes a `String` and an `int` as parameters and prints them.

\subsubsection{Return Types}
The return type of a method specifies the type of value the method will return. It can be any valid data type, including classes and arrays. If the method does not return a value, its return type is `void`.

\textbf{Example:} A method that returns a boolean value.

\begin{lstlisting}[language=Java]
public boolean isAdult(int age) {
    return age >= 18;
}
\end{lstlisting}

This method, `isAdult`, returns `true` if the passed `age` is 18 or older, and `false` otherwise.



\subsection{Method Overloading}
Method overloading is a feature in Java that allows multiple methods to have the same name with different parameters. It increases the readability of the program and allows methods to handle different data types or numbers of inputs.

\textbf{Example:} Overloading the `addNumbers` method.

\begin{lstlisting}[language=Java]
public int addNumbers(int num1, int num2) {
    return num1 + num2;
}

public double addNumbers(double num1, double num2) {
    return num1 + num2;
}
\end{lstlisting}

Here, `addNumbers` is overloaded to handle both integer and double inputs. The appropriate method is called based on the argument types provided during the method call.

\section{Object-Oriented Programming (OOP) Concepts}
\subsection{Detailed Overview of OOP Principles}
Object-Oriented Programming (OOP) is a paradigm centered around objects and data rather than actions and logic. It fundamentally changes the way software is constructed, making it more aligned with how real-world objects and systems are perceived and interacted with. The four pillars of OOP—encapsulation, inheritance, polymorphism, and abstraction—each play a critical role in building software that is robust, reusable, and adaptable.

\subsubsection{Encapsulation}
Encapsulation involves bundling the data (attributes) and the methods (functions) that manipulate the data into a single unit known as a class. It also controls the access to that data, which is a crucial aspect of data security in OOP.

\textbf{In-Depth Explanation:}
- Encapsulation provides a way to protect an object's internal state against unauthorized access and modification from outside the class.
- It enables the developer to hide the internal state and functionality of an object and expose only what is necessary. For example, a class can control its state by making fields private and providing public methods to access and modify them.

\subsubsection{Inheritance}
Inheritance allows a new class to inherit properties and behaviors from an existing class. This mechanism forms a hierarchy and contributes significantly to code reuse and the logical organization of code.

\textbf{In-Depth Explanation:}
- Inheritance facilitates the creation of a new class under the umbrella of an existing class, making it easier to create and maintain an application.
- The concept of inheritance supports the idea of a generalization (parent class) and specialization (child class), where specialized classes inherit features from the more general class.

\subsubsection{Polymorphism}
Polymorphism, meaning 'many forms', allows objects of different classes to be treated as objects of a common superclass. It is a concept that provides a way to perform a single action in different forms.

\textbf{In-Depth Explanation:}
- Polymorphism in Java is implemented through method overloading and overriding, which helps in writing flexible and easily maintainable code.
- It enhances the ability of the program to adapt to new requirements by allowing the same interface to be used for different underlying forms (data types).

\subsubsection{Abstraction}
Abstraction is the process of hiding the complex implementation details and showing only the necessary functionalities to the user. It helps in reducing programming complexity.

\textbf{In-Depth Explanation:}
- Abstraction allows a programmer to focus on what an object does instead of how it does it, providing a simpler interface to complex underlying systems.
- It is implemented in Java through abstract classes and interfaces. Abstract classes provide a partial implementation, which other classes can extend, while interfaces allow the implementation of functionalities across unrelated classes.

These principles of OOP are critical for developing applications that are easy to maintain, modular, and scalable. Understanding and correctly applying these concepts is fundamental to effective software design and implementation in Java.

\section{Classes and Objects}
\subsection{Introduction to Classes and Objects}
In the realm of Object-Oriented Programming (OOP), classes and objects are fundamental concepts that serve as the building blocks of applications. A class is a blueprint from which individual objects are created. It encapsulates data for the object and methods to manipulate that data. An object, on the other hand, is an instance of a class, representing a specific implementation of the class blueprint.

\subsubsection{Defining a Class}
A class is defined in Java using the `class` keyword, followed by the class name and a body containing fields and methods.

\textbf{Example:} Defining a simple class representing a `Book`.

\begin{lstlisting}[language=Java]
public class Book {
    // Fields, attributes, or properties
    String title;
    String author;
    
    // Constructor
    public Book(String title, String author) {
        this.title = title;
        this.author = author;
    }
    
    // Method to display book information
    public void displayInfo() {
        System.out.println("Book: " + title + " by " + author);
    }
}
\end{lstlisting}

This `Book` class includes fields for the `title` and `author` of a book, a constructor to initialize these fields, and a method to display the book information.

\subsubsection{Creating and Using Objects}
Objects are instantiated from a class using the `new` keyword and the class constructor.

\textbf{Example:} Creating and using an object of the `Book` class.

\begin{lstlisting}[language=Java]
public class Main {
    public static void main(String[] args) {
        // Creating an object of the Book class
        Book myBook = new Book("The Hobbit", "J.R.R. Tolkien");
        
        // Using a method of the Book class
        myBook.displayInfo(); // Output: Book: The Hobbit by J.R.R. Tolkien
    }
}
\end{lstlisting}

In this example, an object named `myBook` is created from the `Book` class and initialized with specific title and author. The `displayInfo` method is then called on `myBook` to print its details.

\subsubsection{Use Cases and Significance}
Classes and objects are instrumental in modeling real-world entities and their interactions within software applications. They allow for structured and modular code that can be reused and easily maintained.

- **Encapsulation and Data Hiding:** Classes encapsulate data and operations, offering a clear interface while hiding implementation details.
- **Code Reuse and Scalability:** Through the use of objects, software developers can build upon existing classes to create more complex systems without redundancy.
- **Flexibility through Polymorphism:** Objects of different classes can be treated uniformly, which means methods can operate on objects of different classes if they share a common superclass.

The power of classes and objects lies in their ability to model complex systems in an intuitive way, making software easier to design, implement, test, and maintain.

\subsection{Interfaces}
An interface in Java is a reference type, similar to a class, that can contain only constants, method signatures, default methods, static methods, and nested types. Interfaces cannot contain instance fields or methods with implementations, except static methods and default methods introduced in Java 8.

\textbf{Definition and Usage:}
Interfaces are declared using the `interface` keyword. They are used to specify a set of methods that a class must implement. Interfaces are about capabilities, like being able to compare oneself to another object, or being serializable, and so on.

\begin{lstlisting}[language=Java]
public interface Animal {
    void eat();
    void sleep();
}
\end{lstlisting}

A class implements an interface, thereby inheriting the abstract methods of the interface.

\begin{lstlisting}[language=Java]
public class Dog implements Animal {
    public void eat() {
        System.out.println("Dog is eating");
    }
    
    public void sleep() {
        System.out.println("Dog is sleeping");
    }
}
\end{lstlisting}

Here, `Dog` class implements the `Animal` interface, providing concrete implementations for the `eat` and `sleep` methods.

\subsection{Abstract Classes}
An abstract class in Java is a class that cannot be instantiated on its own and can include abstract and non-abstract methods. Abstract classes are used to provide a common definition of a base class that multiple derived classes can share.

\textbf{Definition and Usage:}
Abstract classes are declared using the `abstract` keyword. They can have both abstract methods (without an implementation) and methods with implementation.

\begin{lstlisting}[language=Java]
public abstract class Shape {
    String color;
    
    // Abstract method
    abstract double area();
    
    // Concrete method
    public String getColor() {
        return color;
    }
}
\end{lstlisting}

A concrete class extends an abstract class and provides implementations for the abstract methods.

\begin{lstlisting}[language=Java]
public class Circle extends Shape {
    double radius;
    
    public Circle(double radius, String color) {
        this.radius = radius;
        this.color = color;
    }
    
    double area() {
        return Math.PI * radius * radius;
    }
}
\end{lstlisting}

In this example, `Circle` extends the `Shape` abstract class, providing its own implementation of the `area` method.

\subsection{Interfaces vs. Abstract Classes}
While both interfaces and abstract classes are used to achieve abstraction in Java, they serve different purposes:

- **Interfaces** are used to define a contract for what a class can do, without specifying how it does it. They are ideal for defining capabilities that can be added to a variety of classes.
- **Abstract Classes** are used when a base class provides a default implementation of certain methods but other methods should be open for customization by subclasses.

Choosing between an interface and an abstract class often depends on the design requirement. If multiple unrelated classes should implement your type, use an interface. If you want to provide common implemented functionality, use an abstract class.


\newpage
\section{Exception Handling}
\subsection{Introduction to Exception Handling}
Exception handling in Java is a powerful mechanism that handles runtime errors, maintaining the normal flow of the application. An exception is an event that disrupts the normal flow of the program's instructions during execution. Java uses a try-catch block to catch exceptions and perform actions to resolve them or gracefully terminate the process.

\subsubsection{Try-Catch Block}
The try-catch block is the central element of exception handling in Java. Code that might throw an exception is enclosed within a `try` block. If an exception occurs within the `try` block, it is caught by a `catch` block that follows it.

\textbf{Basic Syntax:}
\begin{lstlisting}[language=Java]
try {
    // Code that might generate an exception
} catch (ExceptionType name) {
    // Code to handle the exception
}
\end{lstlisting}

\textbf{Example:} Demonstrating a simple try-catch block.

\begin{lstlisting}[language=Java]
try {
    int data = 50/0; // This statement may throw ArithmeticException
} catch (ArithmeticException e) {
    System.out.println(e);
}
System.out.println("Rest of the code...");
\end{lstlisting}

This example catches the `ArithmeticException` caused by dividing an integer by zero and handles it by printing the exception details, thus preventing the program from crashing.

\subsubsection{Multiple Catch Blocks}
A single try block can be followed by multiple catch blocks to handle different types of exceptions separately.

\textbf{Example:} Using multiple catch blocks.

\begin{lstlisting}[language=Java]
try {
    int[] numbers = {1, 2, 3};
    System.out.println(numbers[3]); // This statement may throw ArrayIndexOutOfBoundsException
} catch (ArithmeticException e) {
    System.out.println("Arithmetic Exception");
} catch (ArrayIndexOutOfBoundsException e) {
    System.out.println("Array Index Out Of Bounds Exception");
}
\end{lstlisting}

In this example, if an `ArrayIndexOutOfBoundsException` occurs, the second catch block handles it, providing a more granular control over exception handling.

\subsubsection{Finally Block}
The `finally` block in Java is used to execute a block of code after the try-catch blocks, regardless of whether an exception was caught or not. It is typically used for cleanup code like closing file streams or releasing resources.

\textbf{Example:} Using a finally block.

\begin{lstlisting}[language=Java]
try {
    // Code that might throw an exception
} catch (ExceptionType e) {
    // Exception handler
} finally {
    // Code to be executed after try-catch, regardless of exception
}
\end{lstlisting}

\subsubsection{Throwing Exceptions}
Java allows you to manually throw an exception using the `throw` keyword. This is particularly useful when you want to generate custom exceptions based on certain conditions.

\textbf{Example:} Throwing an exception.

\begin{lstlisting}[language=Java]
public void checkAge(int age) {
    if (age < 18) {
        throw new ArithmeticException("Access denied - You must be at least 18 years old.");
    }
    else {
        System.out.println("Access granted");
    }
}
\end{lstlisting}

This method throws an `ArithmeticException` if the `age` parameter is less than 18, indicating access is denied.

\newpage
\subsubsection{Custom Exceptions}
Java allows the creation of custom exception classes by extending the `Exception` class. This is useful for representing domain-specific error conditions within an application.

\textbf{Example:} Creating a custom exception.

\begin{lstlisting}[language=Java]
class MyException extends Exception {
    public MyException(String message) {
        super(message);
    }
}
\end{lstlisting}

Custom exceptions provide a way to create more descriptive and relevant exceptions tailored to the needs of an application.



\section{Java Standard Libraries}
\subsection{Introduction to Java Standard Libraries}
The Java Standard Libraries, part of the Java Development Kit (JDK), offer an extensive collection of classes and interfaces that facilitate high-level programming tasks. These libraries abstract the complexities of lower-level operations, allowing developers to focus on the logic of their applications. Key areas include the Collections Framework, Input/Output (I/O), Networking, and Concurrency, among others.

\subsubsection{The Collections Framework}
The Collections Framework provides a unified architecture for representing and manipulating collections, enabling developers to handle sets, lists, queues, maps, and more efficiently.

\textbf{Key Classes and Interfaces:}
- **List:** An ordered collection (also known as a sequence). The user can access elements by their integer index. Example implementations include `ArrayList` and `LinkedList`.
- **Set:** A collection that cannot contain duplicate elements. Example implementations include `HashSet` and `TreeSet`.
- **Map:** An object that maps keys to values. A map cannot contain duplicate keys, and each key can map to at most one value. Example implementations include `HashMap` and `TreeMap`.
- **Queue:** A collection used to hold multiple elements prior to processing. Example implementations include `LinkedList` (which implements the `Queue` interface) and `PriorityQueue`.

These interfaces are implemented by various classes in the Java API, providing a wide range of functionalities, from simple storage to complex data structures like trees and hash tables.

\subsubsection{Input/Output (I/O)}
The I/O libraries in Java, primarily found in the `java.io` package, are designed to handle input and output through data streams, serialization, and the file system.

\textbf{Core Concepts:}
- **Streams:** Abstractions for either reading from or writing to various I/O sources like files, memory, and pipes. Streams in Java are categorized into `InputStream` and `OutputStream`.
- **Readers and Writers:** Java provides `Reader` and `Writer` classes for handling character-based I/O operations, facilitating internationalization with Unicode streams.
- **File Handling:** Classes like `File`, `FileInputStream`, `FileOutputStream`, `FileReader`, and `FileWriter` are used for file operations, including file creation, reading, writing, and manipulation.

\subsubsection{Networking}
Java's networking capabilities are encapsulated in the `java.net` package, which includes classes for implementing networking functionalities such as communicating with servers, managing URLs, and developing networked applications.

\textbf{Key Components:}
- **Sockets and ServerSockets:** Facilitate TCP network communication between clients and servers.
- **URL and HttpURLConnection:** Provide support for accessing resources on the internet.

\subsubsection{Concurrency}
The `java.util.concurrent` package provides classes that are essential for writing concurrent programs, enabling multiple threads to run in parallel, thereby improving the performance of complex applications on multicore processors.

\textbf{Concurrency Utilities:}
- **Executors:** Simplify the execution of tasks in asynchronous mode.
- **Concurrent Collections:** Such as `ConcurrentHashMap`, provide thread-safe access to collections.
- **Synchronization Utilities:** Including `CountDownLatch`, `Semaphore`, and `CyclicBarrier`, help manage the synchronization between threads.

These standard libraries significantly reduce the amount of boilerplate code developers need to write, making Java an effective platform for building portable, high-performance applications.



\newpage
\section{File Handling}
\subsection{Introduction to File Handling}
File Handling in Java is a fundamental concept that allows developers to create, read, update, and delete files. Whether managing application logs, reading configuration files, or storing user data, Java's comprehensive I/O libraries make file operations seamless.

\subsubsection{The java.io Package}
The `java.io` package is part of the Java Standard Libraries, providing a classic, stream-oriented approach to file handling.

\textbf{Streams and File Operations:}
- **FileInputStream and FileOutputStream:** Allow for reading from and writing to files in the form of sequences of bytes, suitable for handling all types of files, including binary data.
- **FileReader and FileWriter:** Facilitate reading from and writing to files using characters, making them ideal for processing text files.

\textbf{Buffered Streams:}
- **BufferedReader and BufferedWriter:** Wrap around `FileReader` and `FileWriter` to buffer the input and output, enhancing performance by reducing the number of native I/O operations required.

\textbf{Random Access File:}
- The `RandomAccessFile` class supports both reading and writing to a file at random positions, providing a way to update content anywhere in a file.

\subsubsection{The java.nio Package}
Introduced in JDK 1.4, the `java.nio` package (along with enhancements in later releases) provides a more modern, scalable approach to I/O operations, including file handling.

\textbf{Key Features:}
- **Paths and Files:** The `Paths` class and the `Files` class in the `java.nio.file` package offer static methods to operate on files and directories. `Paths.get()` is used to create a `Path` object, which represents a file or directory path, while the `Files` class provides methods like `createFile`, `copy`, `move`, and `delete`.
- **FileChannel:** Offers a connection to a file for reading, writing, or mapping file content directly into memory for high-efficiency operations.
- **Asynchronous File I/O:** The `AsynchronousFileChannel` class allows for reading from and writing to files asynchronously, improving performance in I/O-intensive applications.

\subsubsection{File Attributes and Operations}
Beyond basic read/write operations, Java provides mechanisms to inspect and modify file attributes, such as permissions, size, modification times, and more, through the `Files` class.

\textbf{Managing Directories:}
- Java supports directory operations such as listing files in a directory, creating directories, and monitoring directory changes in real-time with the Watch Service API.

\subsubsection{Practical Applications and Best Practices}
- **Resource Management:** With the introduction of the try-with-resources statement in Java 7, Java applications can automatically manage resources like file streams, ensuring they are closed after operations are completed, thus preventing resource leaks.
- **Data Processing:** Java's file handling capabilities are extensively used in data processing applications, like reading CSV files, processing log files, and generating reports.

\textbf{Considerations:}
- When dealing with file I/O operations, handling exceptions is crucial. The `java.io.IOException` is commonly encountered and must be properly managed to ensure the application's robustness.
- Choosing between `java.io` and `java.nio` depends on specific use cases. While `java.io` is simpler and covers most needs, `java.nio` offers more flexibility and performance for large-scale operations.

File handling is an integral part of Java programming, touching on almost every aspect of software development. The ability to manipulate files and directories with ease allows Java to serve a wide range of applications, from simple utilities to complex enterprise systems.



\newpage
\section{Advanced Topics in Java}
Java's advanced features empower developers to write more efficient, scalable, and robust code. Understanding these concepts is crucial for tackling complex programming challenges.

\subsection{Multithreading}
Multithreading in Java is a powerful mechanism that allows concurrent execution of two or more parts of a program for maximum utilization of CPU.

\subsubsection{Basics of Threads}
A thread in Java is the path followed when executing a program. All Java programs have at least one thread, known as the main thread, created by the JVM at the program's start.

\textbf{Creating Threads:}
- **Extending the Thread class:** Create a new class that extends `Thread` and override its `run()` method.
- **Implementing the Runnable Interface:** Implement the `Runnable` interface and pass an instance of the class to a `Thread` object.

\textbf{Example:} Implementing the Runnable Interface
\begin{lstlisting}[language=Java]
class HelloRunnable implements Runnable {
    public void run() {
        System.out.println("Hello from a thread!");
    }

    public static void main(String args[]) {
        (new Thread(new HelloRunnable())).start();
    }
}
\end{lstlisting}

\subsubsection{Thread Synchronization}
Thread synchronization is crucial for preventing thread interference and memory consistency errors. The `synchronized` keyword in Java creates a block of code that can only be executed by one thread at a time.

\subsubsection{Thread Communication}
Thread communication in Java is accomplished through methods like `wait()`, `notify()`, and `notifyAll()` that belong to the Object class.

\subsection{Generics}
Generics enable types (classes and interfaces) to be parameters when defining classes, interfaces, and methods. This feature provides stronger type checks at compile time and eliminates the risk of `ClassCastException`.

\textbf{Using Generics:}
\begin{lstlisting}[language=Java]
class Box<T> {
    private T t;

    public void set(T t) { this.t = t; }
    public T get() { return t; }
}
\end{lstlisting}

Generics add stability to your code by making more of your bugs detectable at compile time.

\subsection{Streams}
The Stream API, introduced in Java 8, represents a sequence of objects supporting various methods which can be pipelined to produce the desired result.

\textbf{Stream Operations:}
- **Intermediate Operations:** Transform the stream without consuming it (e.g., `filter`, `map`).
- **Terminal Operations:** Consume the stream to produce a result (e.g., `collect`, `forEach`).

\textbf{Example:} Filtering a list of strings
\begin{lstlisting}[language=Java]
List<String> myList = Arrays.asList("apple", "banana", "cherry");
myList.stream().filter(s -> s.startsWith("a")).forEach(System.out::println);
\end{lstlisting}

\subsection{Java's Networking Capabilities}
Java provides extensive support for networking through the `java.net` package, allowing for the development of networked applications.

\subsubsection{Sockets Programming}
Sockets provide the communication mechanism between two computers using TCP. A server program creates a server socket, while the client program creates a socket.

\textbf{Example:} Creating a Server Socket
\begin{lstlisting}[language=Java]
ServerSocket serverSocket = new ServerSocket(6666);
Socket socket = serverSocket.accept(); //establishes connection
\end{lstlisting}

\newpage
\subsubsection{URL Processing}
Java allows you to manipulate URLs and develop Internet applications with the URL class.

\textbf{Example:} Reading from a URL
\begin{lstlisting}[language=Java]
URL url = new URL("http://example.com");
BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));
String inputLine;
while ((inputLine = in.readLine()) != null)
    System.out.println(inputLine);
in.close();
\end{lstlisting}

---

These advanced topics showcase the depth and flexibility of Java programming. Mastery of multithreading, generics, streams, and networking unlocks the full potential of Java, enabling the development of high-performance, scalable, and sophisticated applications. For further exploration of these concepts or more detailed examples, feel free to inquire.


\section{Conclusion and Further Exploration}

Completing our exploration into advanced Java topics, it's evident that the language's capabilities extend far into creating highly efficient, scalable, and complex applications. The concepts of multithreading, generics, streams, and networking are just the tip of the iceberg, showcasing Java's adaptability to various programming needs and its continued relevance in modern software development.

Java's advanced features, such as multithreading, provide the backbone for high-concurrency applications, enabling them to perform multiple tasks simultaneously, thus improving overall application performance. Generics introduce type safety and reusability, allowing developers to write more generalized and error-resistant code. The Stream API revolutionizes data processing, enabling sophisticated operations on collections with minimal boilerplate. Meanwhile, Java’s robust networking capabilities ensure that applications can communicate over networks efficiently, opening the door to a multitude of distributed applications.

These advanced concepts are not merely academic; they are practical tools that address real-world software development challenges. As Java continues to evolve, staying abreast of these advancements is crucial for developers looking to leverage Java's full potential.

\newpage
\subsection{Recommendations for Further Study}
\begin{itemize}
    \item \textbf{Design Patterns:} Understanding common design patterns in Java can help solve recurring design problems.
    \item \textbf{Java Concurrency Utilities:} Dive deeper into the \texttt{java.util.concurrent} package for more sophisticated thread management and concurrency control.
    \item \textbf{Functional Programming in Java:} Explore more about functional programming introduced in Java 8, including lambda expressions and the \texttt{java.util.function} package.
    \item \textbf{Java Modules:} Introduced in Java 9, the module system adds modularity to Java, making large applications more manageable and secure.
    \item \textbf{Frameworks and Libraries:} Familiarize yourself with popular Java frameworks and libraries like Spring, Hibernate, and Apache Kafka to build enterprise-level applications.
\end{itemize}

\textbf{Final Thoughts}

The journey through Java's advanced topics underscores the language's depth and breadth. From the foundational concepts of OOP to the nuanced details of concurrency and network programming, Java offers a comprehensive ecosystem for developing robust software solutions. By mastering these advanced topics, developers can harness the full power of Java, crafting applications that are not only effective but also efficient, scalable, and maintainable.

Embracing these advanced concepts opens new horizons in Java programming, challenging developers to continually push the boundaries of what's possible. Whether you're building web applications, microservices, or large-scale distributed systems, the advanced features of Java provide the tools you need to succeed in today's dynamic software development landscape.



\newpage
\section{Complet example of a Java program (Parkticket System)}
\subsection{System Overview}
The Parking Ticket System manages vehicle parking within a parking lot, issuing tickets to vehicles on entry and processing payments on exit. The system tracks parked vehicles, calculates parking fees, and manages parking spaces.

\subsection{System Components}
The system is composed of several components: `Vehicle`, `ParkingSpot`, `Ticket`, `PaymentProcessor`, `ParkingLot`, and interfaces such as `Payable`, alongside utility classes for handling concurrency and data processing.

\subsubsection{Defining Vehicle and ParkingSpot Classes}
\begin{lstlisting}[language=Java]
public abstract class Vehicle {
    private String licensePlate;
    public Vehicle(String licensePlate) {
        this.licensePlate = licensePlate;
    }
    public String getLicensePlate() {
        return licensePlate;
    }
}

public class Car extends Vehicle {
    public Car(String licensePlate) {
        super(licensePlate);
    }
}

public class ParkingSpot {
    private boolean isOccupied;
    private Vehicle vehicle;
    public synchronized void parkVehicle(Vehicle vehicle) {
        this.vehicle = vehicle;
        this.isOccupied = true;
    }
    public synchronized void freeSpot() {
        this.vehicle = null;
        this.isOccupied = false;
    }
}
\end{lstlisting}

\subsubsection{Ticket Management and Payment Processing}
\begin{lstlisting}[language=Java]
public class Ticket {
    private final long entryTime;
    private long exitTime;
    private final Vehicle vehicle;
    public Ticket(Vehicle vehicle) {
        this.vehicle = vehicle;
        this.entryTime = System.currentTimeMillis();
    }
    public void setExitTime(long exitTime) {
        this.exitTime = exitTime;
    }
    public double calculateFee() {
        return (exitTime - entryTime) * 0.01; // Simplified fee calculation
    }
}

public interface Payable {
    double calculateFee();
}

public class PaymentProcessor {
    public static void processPayment(Payable payable) {
        System.out.println("Processing payment of: $" + payable.calculateFee());
    }
}
\end{lstlisting}

\newpage
\subsubsection{ParkingLot Management}
\begin{lstlisting}[language=Java]
public class ParkingLot {
    private List<ParkingSpot> spots = new ArrayList<>();
    private Queue<Ticket> ticketQueue = new ConcurrentLinkedQueue<>();
    public ParkingLot(int numberOfSpots) {
        for (int i = 0; i < numberOfSpots; i++) {
            spots.add(new ParkingSpot());
        }
    }
    public synchronized void issueTicket(Vehicle vehicle) {
        for (ParkingSpot spot : spots) {
            if (!spot.isOccupied()) {
                spot.parkVehicle(vehicle);
                Ticket ticket = new Ticket(vehicle);
                ticketQueue.add(ticket);
                break;
            }
        }
    }
    public void processPayments() {
        while (!ticketQueue.isEmpty()) {
            Ticket ticket = ticketQueue.poll();
            ticket.setExitTime(System.currentTimeMillis());
            PaymentProcessor.processPayment(ticket);
        }
    }
}
\end{lstlisting}

\subsubsection{Implementing the System}
To implement the Parking Ticket System, you would instantiate `ParkingLot` with a defined number of `ParkingSpot`s. As `Vehicle`s enter the parking lot, `issueTicket` is called, generating a `Ticket` for each vehicle and parking it in an available spot. Upon exiting, the `processPayments` method calculates the fee based on the duration of the stay and processes the payment.

\subsection{Conclusion}
This conceptual design of a Parking Ticket System in Java demonstrates how to integrate various OOP and advanced programming concepts into a real-world application. From abstract classes and interfaces to generics and multithreading, each element plays a crucial role in building a robust and flexible system. This example provides a foundation upon which more sophisticated features and functionalities can be built, showcasing the power and versatility of Java programming.


\newpage
\section{References}

\begin{enumerate}
        \item Oracle. (n.d.). The Java\texttrademark{} Tutorials. Retrieved from \url{https://docs.oracle.com/javase/tutorial/}
        \item Baeldung. (n.d.). Java Tutorials. Retrieved from \url{https://www.baeldung.com/java-tutorial}
        \item GeeksforGeeks. (n.d.). Java Programming Language. Retrieved from \url{https://www.geeksforgeeks.org/java/}
        \item W3Schools. (n.d.). Java Tutorial. Retrieved from \url{https://www.w3schools.com/java/}
        \item Tutorials Point. (n.d.). Java Tutorial. Retrieved from \url{https://www.tutorialspoint.com/java/index.htm}
        \item Vogella. (n.d.). Java Tutorials. Retrieved from \url{https://www.vogella.com/tutorials/java.html}
        \item Java Code Geeks. (n.d.). Java Tutorials. Retrieved from \url{https://www.javacodegeeks.com/tutorials/java-tutorials/}
        \item JournalDev. (n.d.). Java Tutorials. Retrieved from \url{https://www.journaldev.com/java-tutorials}
        \item JavaTpoint. (n.d.). Java Tutorial. Retrieved from \url{https://www.javatpoint.com/java-tutorial}
        \item Programiz. (n.d.). Java Tutorial. Retrieved from \url{https://www.programiz.com/java-programming}
        \item ChatGPT (2021). Personal knowledge and experience.
\end{enumerate}










\end{document}